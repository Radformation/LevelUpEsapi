<#@ template language="C#" hostspecific="true" debug="false" #>
<#@ assembly name="C:\esapi\13.7\VMS.TPS.Common.Model.API.dll" #>
<#@ assembly name="C:\esapi\13.7\VMS.TPS.Common.Model.Types.dll" #>
<#@ assembly name="C:\esapi\13.7\VMS.TPS.Common.Model.Interface.dll" #>
<#@ assembly name="C:\esapi\13.7\VMS.TPS.Common.Calculation.Interface.dll" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="VMS.TPS.Common.Model.API" #>
<#@ import namespace="VMS.TPS.Common.Model.Types" #>
<#@ output extension=".cs" #>
<#
#>
// <auto-generated>
//     This code was generated by a tool. Do not change this code directly.
// </auto-generated>

using System;
using System.Collections.Generic;
using System.Windows.Media;
using System.Windows.Media.Media3D;
using VMS.TPS.Common.Model.Types;

<#
// Map CLR names used by ESAPI to C# keywords
var TypeAliases = new Dictionary<string,string>
{
    {"String",  "string"},
    {"Int32",   "int"},
    {"Boolean", "bool"},
    {"Double",  "double"},
    {"Single",  "float"},
};

// Helper: render a CLR Type as a C#-style name
string RenderType(Type t)
{
    // Nullable<T> to "T?"
    if (t.IsGenericType && t.GetGenericTypeDefinition() == typeof(Nullable<>))
    {
        var inner = t.GetGenericArguments()[0];
        return $"{inner.Name}?";
    }

    // IEnumerable<T>
    if (t.IsGenericType && t.GetGenericTypeDefinition() == typeof(IEnumerable<>))
    {
        var inner = t.GetGenericArguments()[0];
        var innerName = RenderType(inner);
        return $"IEnumerable<{innerName}>";
    }

    // Other generics: Dictionary<K,V>, etc.
    if (t.IsGenericType)
    {
        var baseName = t.Name.Split('`')[0];
        var args = string.Join(", ", t.GetGenericArguments().Select(RenderType));
        return $"{baseName}<{args}>";
    }

    // CLR types
    if (TypeAliases.TryGetValue(t.Name, out var alias))
        return alias;

    // Fallback for non-generic
    return t.Name;
}

// Helper: if this class has a base in the same assembly, inherit it
string GetBaseName(Type t, Assembly asm)
{
    var bt = t.BaseType;

    if (bt != null && bt != typeof(object) && bt.IsClass && bt.IsPublic && bt.Assembly == asm)
        return bt.Name;
	else
		return null;
}
#>
<#
// Get the ESAPI assembly via a known type: Patient
var asm = typeof(Patient).Assembly;
if (asm == null)
	throw new Exception("Could not load assembly via typeof(Patient).");

// Get all public, non-abstract classes
var types = asm.GetTypes().Where(t => t.IsClass && t.IsPublic);
#>
namespace VMS.TPS.Common.Model.API
{
<#
foreach (var t in types)
{
    var baseName = GetBaseName(t, asm);
    var baseClause = baseName != null ? $" : {baseName}" : string.Empty;

	var props = t.GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly)
        .Where(p => p.CanRead && p.GetIndexParameters().Length == 0);
#>
    public partial class <#= t.Name #><#= baseClause #>
    {
<#
    foreach (var p in props)
    {
        var pt = p.PropertyType;
        if (pt.IsGenericType && pt.GetGenericTypeDefinition() == typeof(IEnumerable<>))
        {
            var innerName = RenderType(pt.GetGenericArguments()[0]);
#>
        public IEnumerable<<#= innerName #>> <#= p.Name #> { get; set; }
<#
        }
        else
        {
#>
        public <#= RenderType(pt) #> <#= p.Name #> { get; set; }
<#
        }
    }
#>
    }

<#
}
#>
}

